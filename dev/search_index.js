var documenterSearchIndex = {"docs":
[{"location":"#Underscores.jl-1","page":"Home","title":"Underscores.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = :(using Underscores)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Underscores provides a macro @_ for passing closures to functions by interpreting _ placeholders as anonymous function arguments. For example @_ map(_+1, xs) means map(x->x+1, xs).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Underscores is useful for writing anonymous functions succinctly and without naming the arguments. This is particular useful for data processing pipelines such as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@_ people |> filter(_.age > 40, __) |> map(_.name, __)","category":"page"},{"location":"#Tutorial-1","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"#Basic-use-of-_-1","page":"Home","title":"Basic use of _","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@_ and _ placeholders are for making functions to pass to other functions. For example, to get the second last element of each array in a collection, broadcasting syntax would be awkward. Instead we can use:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @_ map(_[end-1],  [[1,2,3], [4,5]])\n2-element Array{Int64,1}:\n 2\n 4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Repeated use of _ refers to the argument of a single-argument anonymous function. To sum the last two elements of the arrays from the previous example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @_ map(_[end] + _[end-1],  [[1,2,3], [4,5]])\n2-element Array{Int64,1}:\n 5\n 9","category":"page"},{"location":"#Multiple-arguments-1","page":"Home","title":"Multiple arguments","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Multiple argument anonymous functions can be created with numbered placeholders like _1 can be useful when you need to repeat arguments or reorder them. For example,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @_ map(\"X $_2 $(repeat(_1,_2))\", [\"a\",\"b\",\"c\"], [1,2,3])\n3-element Array{String,1}:\n \"X 1 a\"\n \"X 2 bb\"\n \"X 3 ccc\"","category":"page"},{"location":"#Tabular-data-1","page":"Home","title":"Tabular data","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@_ is handy for manipulating tabular data. Let's filter a list of named tuples:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> table = [(x=\"a\", y=1),\n                (x=\"b\", y=2),\n                (x=\"c\", y=3)];\n\njulia> @_ filter(!startswith(_.x, \"a\"), table)\n2-element Array{NamedTuple{(:x, :y),Tuple{String,Int64}},1}:\n (x = \"b\", y = 2)\n (x = \"c\", y = 3)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"When combined with double underscore placeholders __ and piping syntax this becomes particularly neat. In the following, think of __ as the table, and _ as an individual row:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @_ table |>\n          filter(!startswith(_.x, \"a\"), __) |>\n          map(_.y, __)\n2-element Array{Int64,1}:\n 2\n 3","category":"page"},{"location":"#Reference-1","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@_","category":"page"},{"location":"#Underscores.@_","page":"Home","title":"Underscores.@_","text":"@_ func(ex1, [ex2 ...])\n\nConvert ex1,ex2,... into anonymous functions when they have _ placeholders, and pass them along to func.\n\nThe detailed rules are:\n\nUses of the placeholder _ expand to the single argument of an anonymous function which is passed to the outermost expression.\nNumbered placeholders _1,_2,... (or _₁,_₂,...) may be used if you need more than one argument. Numbers indicate position in the argument list.\nThe double underscore placeholder __ (and numbered versions __1,__2,...) expands the closure scope to the whole expression.\nPiping and composition chains with |>,<|,∘ are treated as a special case where the replacement recurses into sub-expressions.\n\nThese rules imply the following equivalences\n\nExpression Rules Meaning\n@_ map(_+1, a) (1) map(x->x+1, a)\n@_ map(_^_, a) (1) map(x->x^x, a)\n@_ map(_2/_1, a, b) (1,2) map((x,y)->y/x, a, b)\n@_ func(a,__,b) (3) x->func(a,x,b)\n@_ func(a,__2,b) (3) (x,y)->func(a,y,b)\n@_ data |> map(_.f,__) (1,3,4) data |> (d->map(x->x.f,d))\n\nExtended help\n\nExamples\n\n@_ can be used for simple mapping operations in cases where broadcasting syntax is awkward. For example, to get the second last element of each array in a collection:\n\njulia> @_ map(_[end-1],  [[1,2,3], [4,5]])\n2-element Array{Int64,1}:\n 2\n 4\n\nIf you need to repeat an argument more than once, just use _ multiple times:\n\njulia> @_ map(_^_,  [1,2,3])\n3-element Array{Int64,1}:\n  1\n  4\n 27\n\nFor manipulating tabular data @_ provides convenient syntax which is especially useful when combined with double underscore placeholders __ and piping syntax. Think of __ as the table, and _ as an individual row:\n\njulia> table = [(x=\"a\", y=1),\n                (x=\"b\", y=2),\n                (x=\"c\", y=3)];\n\njulia> @_ table |>\n          filter(!startswith(_.x, \"a\"), __) |>\n          map(_.y, __)\n2-element Array{Int64,1}:\n 2\n 3\n\n\n\n\n\n","category":"macro"},{"location":"#Design-1","page":"Home","title":"Design","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Underscore syntax for Julia has been discussed at great length in #24990, #5571 and elsewhere in the Julia community. The design for Underscores.jl grew out of this discussion. A great many packages have had a go at macros for this, including at least ChainMap.jl, ChainRecursive.jl, FunctionalData.jl, Hose.jl, Lazy.jl, LightQuery.jl, LambdaFn.jl, MagicUnderscores.jl, Pipe.jl, Query.jl and SplitApplyCombine.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The key benefits of _ placeholders are","category":"page"},{"location":"#","page":"Home","title":"Home","text":"They avoid the need to come up with argument names (for example, the x in x->x+1 may not be meaningful).\nBrevity. For example _+1.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One design difficulty is that much of the package work has focussed on the piping and tabular data manipulation scenario. However as a language feature a compelling general solution for _ placeholders needs wider appeal.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Starting with the need to be useful outside of tabular data manipulation, we observe that anonymous functions are generally passed directly to another \"outer\" function. For example, in map(x->x*y, A) the outer function is map. However, putting @_ inside the function call leads to a lot of visual clutter, especially because it needs to be parenthesized to avoid consuming the remaining arguments to map. However, one can place the @_ on the function receiving the closure which results in less visual clutter and improved clarity. Compare:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@_ map(_+1, A)   # This design\n\nmap(@_(_+1), A)  # The obvious alternative\n\nmap(x->x+1, A)   # Current status quo","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With this \"outermost-but-one\" placement in mind, one can generalize to pipelines where anonymous functions are generally used as arguments to filter and map. This works in a particularly nice way for lazy versions of Filter and Map, allowing expressions such as","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Filter(f) = x->filter(f,x);   Map(f) = x->map(f,x);\n\n@_  data         |>\n    Filter(_>10) |>\n    Map(_+1)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, julia natively has non-lazy filter and map so we'd really like a way to make these directly useable as well. For this we introduce the longer placeholder __ to escape the extra function call to the outer level. This is also appealing because the larger data structure (ie, the full table) ends up being represented by __, while the smaller row data structure is the smaller placeholder _. Thus we get:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@_  data             |>\n    filter(_>10, __) |>\n    map(_+1, __)","category":"page"}]
}
